# Задание по проекту на дом - 3


## Командное разделение
Команда А, X:  
* Абстрактная модель

Команда K, R:  
* Общий источник данных

## Суть фичей

#### Абстрактная модель

В пакете data_model создаем файл `abstract_model.py` и в нем пишем класс `AbstractModel(ABC)`. Необходимо вынести наши общие методы в этот абстрактный класс и все наши модели отнаследовать от него.

Обратите внимание, часть методов абстрактные и должны быть реализованы в каждом из классов, но быть объявлены в абстрактном!

```python
from abc import ABC, abstractmethod

class AbstractModel(ABC):
    def save(self):
        pass


    def serialize_to_json(self, indent: Optional[int] = None) -> str:
        pass


    @classmethod
    def get_all(cls, db_path: str = './db'):
        pass


    @classmethod
    def get_by_id(cls, elem_id: int, db_path: str = './db'):
        pass

    
    @classmethod
    def _read_json_db(cls, db_path: str) -> list[dict]:
        pass


    @staticmethod
    def _serialize_records_to_json(records: list[dict], indent: Optional[int] = None):
        pass


    @abstractmethod
    def __str__(self):
        pass


    @abstractmethod
    def __dict__(self):
        pass


    @abstractmethod
    def get_main_id(self):
        pass
```

#### Общий источник данных

В пакете `adapters` (добавьте `__init__.py`) создайте файл `file_source.py` а в нем класс `FileSource`. В рамках данного класса необходимо реализовать 6 методов для доступа к данным.

```python
class FileSource:
    def __init__(self, dp_path: str = './db'):
        pass


    def get_all(self, collection_name: str) -> list[dict]:
        pass


    def get_by_id(self, collection_name: str, elem_id: int) -> dict:
        pass


    def get_by_query(self, collection_name: str, query: dict[str, Any]) -> list[dict]:
        pass


    def insert(self, collection_name: str, document: dict) -> dict:
        pass


    def update(self, collection_name: str, elem_id: int, document: dict) -> dict:
        pass

    
    def delete(self, collection_name: str, elem_id: int) -> dict:
        pass
```

* Конструктор `__init__` принимает на вход путь до папки с json базой данных и сохраняет это значение в private свойстве объекта

* Метод `get_all` принимает на вход имя коллекции данных (имя класса, который вызывает этот метод), считывает из нужного файла все данные и возвращает их в виде массива диктов

* Метод `get_by_id` принимает на вход имя коллекции данных (имя класса, который вызывает этот метод) и id искомого объекта. Метод считывает данные из файла, ищет первый попавшийся элемент с совпадающим id и возвращает его. Важное уточнение во всех классах необходимо поле с id элементом привести к единому формату. Например, в `teacher.py` основным id является `teacher_id`, необходимо переименовать это поле в `object_id`. И так для всех классов.

* Метод `get_by_query` принимает на вход имя коллекции данных (имя класса, который вызывает этот метод) и query dict, например `{ "start_time": 10, "end_time": 20 }`. Метод считывает данные из файла и возвращает все элементы в которых все ключи из query имеют те же значения.

* Метод `insert` принимает на вход имя коллекции данных (имя класса, который вызывает этот метод) и dict объект, который необходимо сохранить. Важный момент, метод `insert` должен использоваться только для сохранения новых объектов, соответственно **поля `object_id` в них быть не должно**. При сохранении объекта необходимо назначить объекту новый id. Id должен быть целым уникальным числом, **в пределах одного json файла не должно быть двух объектов с одинаковым id**

* Метод `update` принимает на вход имя коллекции данных (имя класса, который вызывает этот метод), id элемента для обновления и dict объект с данными обновления. Поле `object_id` во входном `dict` нужно считать не обновляемым и не в коем случае не перезаписывать его.

* Метод `delete` принимает на вход имя коллекции данных (имя класса, который вызывает этот метод) и id элемента, который необходимо удалить